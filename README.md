# Реализация кастомного пула потоков

## Обзор реализации

`CustomThreadPool` является расширяемым и настраиваемым пулом потоков с поддержкой метрик, балансировки нагрузки и различных политик обработки отказа.

### Ключевые особенности:

1. **Гибкая настройка параметров**:
    - corePoolSize, maxPoolSize
    - keepAliveTime для избыточных потоков
    - queueSize для ограничения очередей
    - minSpareThreads для поддержания резерва потоков

2. **Распределение задач**:
    - Используется стратегия "наименьшая загруженность" (Least Loaded)
    - Каждый поток имеет свою очередь задач

3. **Политики отказа**:
    - Реализованы стандартные политики (Abort, CallerRuns, Discard)
    - Возможность добавления собственных политик

4. **Метрики**:
    - Сбор статистики по выполненным задачам
    - Время выполнения, размер очереди, отклоненные задачи

5. **Управление жизненным циклом**:
    - Плавное завершение (shutdown)
    - Принудительное завершение (shutdownNow)
    - Ожидание завершения (awaitTermination)

## Производительность

### Сравнение со стандартными пулами

1. **ThreadPoolExecutor (стандартный)**:
    - Использует единую очередь для всех потоков
    - Более простая реализация, но может быть узким местом при высокой нагрузке
    - Нет поддержки minSpareThreads

2. **ForkJoinPool**:
    - Оптимизирован для задач с разделяемой работой
    - Использует work-stealing алгоритм
    - Не подходит для независимых задач

3. **CustomThreadPool (текущая реализация)**:
    + Множественные очереди уменьшают конкуренцию
    + Балансировка нагрузки между очередями
    + Поддержка minSpareThreads для быстрого реагирования на всплески нагрузки
    - Более сложная реализация
    - Дополнительные накладные расходы на управление несколькими очередями

### Оптимальные параметры

На основе тестирования можно выделить следующие рекомендации:

1. **corePoolSize**: 2-4 потока на ядро CPU для CPU-bound задач
2. **maxPoolSize**: В 2-4 раза больше corePoolSize для I/O-bound задач
3. **queueSize**: 50-100 задач на поток
4. **minSpareThreads**: 1-2 потока для быстрого реагирования
5. **keepAliveTime**: 30-60 секунд для баланса между ресурсами и отзывчивостью

## Принцип работы балансировки

Реализованный алгоритм балансировки использует подход "наименьшая загруженность":

1. Каждый рабочий поток имеет свою очередь задач
2. При поступлении новой задачи:
    - Сканируются все очереди
    - Выбирается очередь с наименьшим количеством задач
    - Задача добавляется в эту очередь

Преимущества:
- Равномерное распределение нагрузки
- Минимизация времени ожидания задач
- Простота реализации
- По сравнению с Round Robin позволяет обработать не отклоняя большее количество задач

Недостатки:
- Небольшие накладные расходы на выбор очереди
- Не учитывает сложность задач (все задачи считаются равными)

## Политики отказа

1. **AbortPolicy (по умолчанию)**:
    - Выбрасывает RejectedExecutionException
    - Подходит для систем, где важно знать о перегрузке

2. **CallerRunsPolicy**:
    - Выполняет задачу в вызывающем потоке
    - Естественное ограничение скорости подачи задач

3. **DiscardPolicy**:
    - Молча игнорирует отклоненные задачи
    - Подходит для не критичных задач

Выбор политики зависит от требований приложения. В демонстрационной программе используется AbortPolicy для явного контроля перегрузки.

## Заключение

Реализованный `CustomThreadPool` предоставляет гибкий механизм управления потоками с возможностью тонкой настройки под конкретные требования. Поддержка метрик позволяет анализировать производительность и оптимизировать параметры.

Основные преимущества перед стандартными пулами:
- Более гибкое управление потоками
- Поддержка minSpareThreads
- Распределение задач между несколькими очередями
- Расширяемая система метрик

Для большинства случаев стандартный ThreadPoolExecutor будет достаточным, но в высоконагруженных системах с особыми требованиями представленная реализация может быть более эффективной.